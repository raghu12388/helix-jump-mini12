<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Stack Ball – Clean Rings</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#111;
  font-family:Arial;
}
canvas{display:block}

/* UI */
#ui{
  position:fixed;
  top:10px;
  width:100%;
  text-align:center;
  color:white;
  font-size:16px;
  z-index:10;
}
</style>
</head>

<body>

<div id="ui">Score: <span id="score">0</span></div>
<canvas id="c"></canvas>

<script>
/* ================= CANVAS ================= */
const c=document.getElementById("c");
const ctx=c.getContext("2d");
const resize=()=>{c.width=innerWidth;c.height=innerHeight};
resize();addEventListener("resize",resize);

const CX=()=>c.width/2;

/* ================= GAME STATE ================= */
let score=0;
const scoreEl=document.getElementById("score");
let running=true;
let press=false;

/* ================= BALL ================= */
const ball={x:CX(),y:120,r:12,vy:0};
const gravity=0.55;

/* ================= INPUT ================= */
addEventListener("pointerdown",()=>press=true);
addEventListener("pointerup",()=>press=false);

/* ================= RINGS ================= */
const rings=[];
const GAP_Y=120;
const RADIUS=80;
const THICK=18;
const GAP_SIZE=Math.PI/2.5;   // clean visible gap

function spawnRing(y){
  return{
    y,
    gapStart:Math.random()*Math.PI*2,
    broken:false
  };
}

function build(){
  rings.length=0;
  for(let i=0;i<10;i++){
    rings.push(spawnRing(260+i*GAP_Y));
  }
}
build();

/* ================= UPDATE ================= */
function update(){
  if(!running) return;

  ball.vy += press ? gravity*1.3 : gravity;
  ball.y  += ball.vy;

  rings.forEach(r=>{
    r.y -= 2.4;   // smooth speed

    const dy = ball.y - r.y;
    if(Math.abs(dy) < THICK/2 && !r.broken){
      const angle = Math.PI*1.5; // ball always front
      const end = r.gapStart + GAP_SIZE;

      // If NOT inside gap → collision
      if(!(angle > r.gapStart && angle < end)){
        if(press){
          r.broken=true;
          score+=10;
          scoreEl.textContent=score;
        }else{
          ball.vy=-10;
        }
      }
    }

    if(r.y < -50){
      r.y = c.height + GAP_Y;
      r.gapStart = Math.random()*Math.PI*2;
      r.broken=false;
    }
  });

  if(ball.y > c.height+50){
    score=0;
    scoreEl.textContent=0;
    ball.y=120;
    ball.vy=0;
    build();
  }
}

/* ================= DRAW ================= */
function draw(){
  ctx.clearRect(0,0,c.width,c.height);

  // Tower
  ctx.fillStyle="#00e5ff";
  ctx.fillRect(CX()-18,0,36,c.height);

  // Rings
  rings.forEach(r=>{
    if(r.broken) return;

    ctx.beginPath();
    ctx.lineWidth=THICK;
    ctx.strokeStyle="#00ff88";

    // draw ring except gap
    ctx.arc(
      CX(),
      r.y,
      RADIUS,
      r.gapStart + GAP_SIZE,
      r.gapStart + Math.PI*2
    );
    ctx.stroke();
  });

  // Ball
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
  ctx.fillStyle="red";
  ctx.fill();
}

/* ================= LOOP ================= */
(function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
})();
</script>

</body>
</html>
