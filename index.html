<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Stack Ball Mini</title>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#111;
  font-family:Arial;
}
canvas{display:block;}

#ui{
  position:fixed;
  top:10px;
  width:100%;
  text-align:center;
  color:white;
  font-size:18px;
}

#gameover{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.75);
  display:none;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  color:white;
  font-size:22px;
}

#gameover button{
  margin-top:20px;
  padding:12px 30px;
  font-size:18px;
  border:none;
  border-radius:6px;
  background:#00ff88;
}
</style>
</head>

<body>

<div id="ui">Score: 0 | Combo: 0</div>

<div id="gameover">
  <div>ðŸ’¥ GAME OVER</div>
  <div id="finalScore" style="margin-top:10px;"></div>
  <button onclick="restart()">Tap to Restart</button>
</div>

<canvas id="c"></canvas>

<script>
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
const ui=document.getElementById("ui");
const over=document.getElementById("gameover");
const finalScore=document.getElementById("finalScore");

function resize(){
  canvas.width=innerWidth;
  canvas.height=innerHeight;
}
resize(); addEventListener("resize",resize);

const CX=()=>canvas.width/2;

// GAME STATE
let score=0, combo=0, fire=false, running=true;
let press=false;

// BALL
const ball={
  x:CX(),
  y:120,
  r:12,
  vy:0
};

const gravity=0.7;

// INPUT
addEventListener("pointerdown",()=>press=true);
addEventListener("pointerup",()=>{
  press=false;
  combo=0;
  fire=false;
});

// RINGS
const rings=[];
const gap=120;

function spawn(y){
  return{
    y,
    gapAngle:Math.random()*Math.PI*2,
    broken:false
  };
}

function resetRings(){
  rings.length=0;
  for(let i=0;i<8;i++) rings.push(spawn(260+i*gap));
}
resetRings();

// UPDATE
function update(){
  if(!running) return;

  ball.vy += press ? gravity*2 : gravity;
  ball.y += ball.vy;

  if(press){
    combo++;
    if(combo>40) fire=true;
  }

  rings.forEach(r=>{
    r.y -= fire ? 6 : 3;

    const dy = ball.y - r.y;
    if(Math.abs(dy)<10 && !r.broken){
      const angle=Math.atan2(ball.x-CX(),0)+Math.PI/2;
      const diff=Math.abs(angle-r.gapAngle);

      if(diff<0.6 || fire){
        r.broken=true;
        score++;
      }else{
        gameOver();
      }
    }

    if(r.y<-60){
      r.y=canvas.height+gap;
      r.broken=false;
      r.gapAngle=Math.random()*Math.PI*2;
    }
  });

  if(ball.y>canvas.height+50) gameOver();

  ui.textContent=`Score: ${score} | Combo: ${combo} ${fire?"ðŸ”¥":""}`;
}

// DRAW
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // tower
  ctx.fillStyle="#00e5ff";
  ctx.fillRect(CX()-18,0,36,canvas.height);

  // rings
  rings.forEach(r=>{
    if(r.broken) return;
    ctx.beginPath();
    ctx.lineWidth=18;
    ctx.strokeStyle=fire?"#ff4500":"#00ff88";
    ctx.arc(CX(),r.y,80,r.gapAngle+0.8,r.gapAngle+Math.PI*2);
    ctx.stroke();
  });

  // ball
  ctx.beginPath();
  ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2);
  ctx.fillStyle=fire?"orange":"red";
  ctx.shadowColor=fire?"orange":"transparent";
  ctx.shadowBlur=fire?20:0;
  ctx.fill();
  ctx.shadowBlur=0;
}

// GAME OVER
function gameOver(){
  running=false;
  over.style.display="flex";
  finalScore.textContent="Score: "+score;
}

// RESTART
function restart(){
  score=0; combo=0; fire=false;
  ball.y=120; ball.vy=0;
  resetRings();
  running=true;
  over.style.display="none";
}

// LOOP
(function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
